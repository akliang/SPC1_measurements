
clear all
close all
fclose('all');
flag.dryrun=true;
flag.dryrun=false;

%{ 
   Matlab Controlled G3 Measurements

   Current Guiding Principles:
    - a single (not anymore) MATLAB-script controls the acquisition
        - why script and not function? -> debugging easier. if a function bails out in production, all internal states are lost.
    - concise, compact, not convoluted
    - try to use all variables as part of a struct to clarify their scope
%}

%{
   This version is based on Hao's trapping extension of the original measurement script
   kaon:/home/user/Desktop/Hao/MD88_7293_11B/2011-11-22/meas_Trapping.m
   put back under svn control on 2012-05-08 for Gen2 PSI-1 measurements by mk
   $HeadURL$
   $Id$
%}


% Setup descriptions in external file now
% (too many arrays, and too many different measurement scripts made this necessary)

meas_desc_gen2g3
%{
setup.LOCATION='Argus Building, RF Lab';
setup.G3_system='5of9-vanilla';
setup.G3_interface='a4-V20-20100408'; % serial number - hardware version - bitfile version
setup.G3_adcCards='b1-b2-b3-b4-00-00-00-00';

setup.POWER_G3='ArrayAndADCPower#2';
setup.POWER_ADC='ArrayAndADCPower#2';
setup.POWER_ARRAY='BK9130#1';


setup.ARRAYTYPE='Gen2_PSI1';
setup.WAFERCODE='29B1-6';
setup.PLATFORM='PG-G1-10-11';
%setup.WAFERCODE='29B1-1';
%setup.PLATFORM='PG-G1-10-10';
setup.PF_dataCards='a5-a6-a8'; % first is the outermost, last is the innermost
setup.PF_dataCardDIPs='1111111100'; % [ ~PG1 ~PG2 ~PG3 ~PG4 ~PG5 ~PG6 BW2-HI BW1-HI 16CH UP ]
setup.PF_dataCardVref='0.86'; % nominal Vref, set by resistor divider
setup.PF_dataBoardDIPs='01000000'; % [ PG3 PG4 PG5 CTRL9 CTRL10 CTRL12 CTRL11 ?? ]
%setup.PF_dataBoardJumper='JP1=Vbias1';
setup.PF_gateCards='00-xx';
setup.PF_analogCard='V1N1';
setup.PF_arrayLogic='none';
setup.PF_arrayLogicDIPs='0'; % no array logic, i.e. no dips
setup.PF_CrossCable='normal';
setup.special='';
%}

env.V=[];
env.V(end+1)= -4.0  ; id.AVoff   =numel(env.V);                             % Test Point near to Gate Card
env.V(end+1)=  15.0 ; id.Von     =numel(env.V);                             % Test Point near to Gate Card
env.V(end+1)=  0.0  ; id.Vout10  =numel(env.V);   id.RevBias =numel(env.V); % Vn.Vout10=0.0;  %PSI3: Vn.RevBias=-2.5;         % Vout10
env.V(end+1)=  0.0  ; id.Vout9   =numel(env.V);   id.Vreset  =numel(env.V); % Vn.Vout9=0.0;   %PSI3: Vn.Vreset=15.0;          % Vout9
env.V(end+1)=  0.0  ; id.Vout8   =numel(env.V);   id.Vcc     =numel(env.V); % Vn.Vout8=0.0;   %PSI3: Vn.Vcc=8;                % Vout8
env.V(end+1)=  0.0  ; id.Vguard2 =numel(env.V);   id.Tbias   =numel(env.V); % Vn.Vguard2=0.0; %PSI3: Vn.Tbias=5.5;            % Vout7
env.V(end+1)=  0.0  ; id.Vguard1 =numel(env.V);   id.Vgnd    =numel(env.V); % Vn.Vguard1=0.0; %PSI3: Vn.Vgnd=1.0;             % Vout6
env.V(end+1)=  0.0  ; id.Vbias2  =numel(env.V);   id.MuxHigh =numel(env.V); % Vn.Vbias2=0.0 ; %PSI3: Vn.Mux_High=15.0;        % Vout5
env.V(end+1)= -2.0  ; id.Vbias   =numel(env.V);                   % Vn.Vbias=-3.0;   env.V(end+1)=env.V(id.Vgnd)   env.V(id.Vreset)  % Vout4
env.V(end+1)=  1.0  ; id.VQinj   =numel(env.V);                              % Vn.Qinj=2.0; % toggle between 1 and 2 V         % Vout3
env.V(end+1)=  0.863; id.Vref    =numel(env.V);                             % Vn.Vref=0.856; 2.303  for PSI2/3 cards  %   usually generated by R/R on Masda-R card
env.V(end+1)=  0    ; id.DLrstGate =numel(env.V);                  % env.V(id.Vguard2)
env.V(end+1)=  0    ; id.DLrstGnd   =numel(env.V);                           % hard-wired to Analog Ground on PSI-2
env.V(end+1)=  0    ; id.SRCommon   =numel(env.V);                           
env.V(end+1)=  0    ; id.dummy1   =numel(env.V); 
env.V(end+1)=  0    ; id.dummy2   =numel(env.V);
env.V(end+1)=  0    ; id.dummy2   =numel(env.V);

env.I.V24m=0.000;  % Current in amperes on the BK PRECISION -24V power supply
env.I.V24p=0.000;  % Current in amperes on the BK PRECISION +24V power supply

meas.MFileDesc=[ mfilename() '.m' ];




%
% Experimental Environment Description, part 2:
%   heavily measurement-type dependent settings
%

%env.G3ExtClock=100000; env.UseExtClock=1;
env.G3ExtClock=0; env.UseExtClock=0;



%
% Array-Type dependent settings & calculations
%

% Gen2 PSI-1 array on Gen
    geo.G3_SORTMODE=10;
    geo.GL=128;
    geo.G3GL=geo.GL-1;
    geo.DL=512;
    geo.G3DL=floor((geo.DL+1)/512)*512/2 -1;
    



%
% Multi-Sequence-Setup
%

meas.DUT=[ setup.ARRAYTYPE '_' setup.WAFERCODE ];

meas.MeasCond='LED'; multi.R22=0; % setting: PG4
%meas.MeasCond='Qinj'; multi.R22=0; % setting: PG4

% technically, not only R's can be changed in multi-sequence mode - 
% is RMATRIX an inappropriate name?

multi.RMATRIX=[
   %R1    R25   R26    R27 
   0        0  1000    400
   0       25   000    400
   0       50   000    400
   0       75   000    400
   0      100   000    400
   0      125   000    400
   0      150   000    400
   0      175   000    400
   0      200   000    400
];
%{
multi.RMATRIX=[
   %R1    R25   R26    R27 
   0        0   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
   0       50   000   1000
];
%}

%multi.RMATRIX=repmat(multi.RMATRIX,[1 1]);

multi.nrofacq=size(multi.RMATRIX,1);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%RBC
%multi.mid=1;
%pause;
%if strcmp(meas.MeasCond(1:5),'First'); multi.nrofacq=1; end
if strcmp(meas.MeasCond(1:3),'Qin' ); multi.nrofacq=1; end

meas.MeasDetails=[ sprintf('%s', meas.MeasCond) ...
    sprintf( '_Vbias%s', volt2str(env.V(id.Vbias)) ) ... not needed for PSI-2/3
    ...sprintf( '_Vrst%s', volt2str(env.V(id.Vreset)) ) ... for AP pixels 
    sprintf( '_Von%s', volt2str(env.V(id.Von)) ) ... not needed for PSI-2/3
    sprintf( '_Voff%s', volt2str(env.V(id.AVoff)) ) ... not needed for PSI-2/3
    ...sprintf( '_Vgnd%s', volt2str(env.V(id.Vgnd)) ) ...
    ...sprintf( '_Tbias%s', volt2str(env.V(id.Tbias)) ) ...
    ...sprintf( '_Vcc%s', volt2str(env.V(id.Vcc)) ) ...  for AP pixels 
    ...sprintf( '_Voff%s',  volt2str(env.V(id.AVoff)) ) ...    
    sprintf( '_VQinj%s', volt2str(env.V(id.VQinj)) ) ...
    ...sprintf( '_%02dR22', multi.R22                 ) ...
    ...sprintf( '_RST%s',    setup.PF_globalReset     ) ...
    sprintf( '%s',    setup.special     ) ...
    ...sprintf( '_GC%s',    setup.PF_gateCards        ) ...
    ...sprintf( '_DC%s',    setup.PF_dataCards        ) ...
    ...sprintf( '_GL%03d',  geo.GL                    ) ...
   ];


meas.MeasID=datestr(now(),30);
meas.DirName=[ '../measurements/' meas.DUT '/' meas.MeasID '_' meas.MeasDetails '/' ]
meas.MFile=[ mfilename() '.m' ];
if ~flag.dryrun;
    mkdir(meas.DirName);    
    copyfile(meas.MFile,[ meas.DirName meas.MFile ]);
    copyfile(meas.MFileDesc,[ meas.DirName meas.MFileDesc ]);
end;

%
% Multi-Sequence Loop
%

flag.G3_nuke=true;
flag.first_run=true;
flag.finished=false;
for mid=1:multi.nrofacq; multi.mid=mid;

   multi.R1 =multi.RMATRIX(multi.mid,1);
   multi.R25=multi.RMATRIX(multi.mid,2);
   multi.R26=multi.RMATRIX(multi.mid,3);
   multi.R27=multi.RMATRIX(multi.mid,4);
   
   multi.R11=0;
   multi.R13=1;
   multi.R14=1;
   
   disp(multi);
    
meas.BaseName=[ meas.DirName ...
    meas.MeasID '_' meas.MeasCond ... '_' meas.DUT   ...
    sprintf( '_Vbias%s', volt2str(env.V(id.Vbias)) )...
    sprintf( '_Voff%s', volt2str(env.V(id.AVoff)) ) ... 
 ...%sprintf('_Acq%03d', multi.mid) ...
 ...'_' meas.MeasDetails ...    
 ...sprintf('_%05dR1' , multi.R1)   ...
 ...sprintf('_%05dR3' , multi.R3)   ...
 ...sprintf('_%02dR4' , multi.R4)   ...
 ...sprintf('_%02dR21', multi.R21)  ...
 ...sprintf('_%02dR5' , multi.R5)   ...
 ...sprintf('_%02dR6' , multi.R6)   ...
 ...sprintf('_%05dR11', multi.R11)  ...
 ...sprintf('_%05dR13', multi.R13)  ...
 ...sprintf('_%05dR14', multi.R14)  ...
 ...sprintf('_%02dR22', multi.R22)  ...
 ...sprintf('_%03dR25', multi.R25)  ...
 ...sprintf('_%03dR26', multi.R26)  ...
 ...sprintf('_%03dR27', multi.R27)  ...    
    %sprintf('_%03dkVp', multi.xraykVp)  ...  
    %sprintf('_%03dms',  multi.xrayTime) ...    
    %sprintf('_%03dmA',  multi.xrayCur)  ...    
 ];

meas.AcqFile=[ pwd() '/' meas.BaseName '.bin' ];
meas.MatFile=[ meas.BaseName sprintf('.%03d',multi.mid) '.settings.mat' ];

% Masda-R Gain Setting? How to record them?
% Jumper Configuration?
% G3Ext registers?
% easily switch between sets of values? good visualization?
% more array types...?

meas.R=[
 %value PSI-1 PSI-2 PSI-3   %name  bits  (default)units        Description
        multi.R1            %R1    16    (512)us   (F9==0)  Tau_1:   Primary Delay between Readouts. R1*512Mhz/tau1_clk ; tau1_clk=(F9==0)?1Mhz:extclock
        49472               %R2    16      (8)us  (F10==0)  Tau_2: Secondary Delay between Readouts, e.g. for LED-Flashing, starts after Tau_1, R2*8/tau2_clk ; tau2_clk=(F10==0)?1Mhz:extclock
        0                   %R3    16      (8)us  (F11==0)  Tau_3: Delay between Gate Line Groups. R3*8Mhz/tau3_clk ; tau3_clk=(F11==0)?1Mhz:extclock
        1200                %R4    14      50 ns            Tau_4: preamp integration time (SAFT): R4*50ns ; starts 1.75us after Tau_21 [?? Tint=3.9+0.05(R21+R4-R5) in us]
        400                 %R5    12      50 ns            Tau_5: Gate Hold-off, i.e. delay before Gate-On, 0.05us*R5, for non-multiplexed arrays larger than 2.15us+0.05us*R21+1.75us
        1600                %R6    16      50 ns            Tau_6: Gate-On-Time, 0.05us*R6, starts after Tau_5
        0                   %R7          N/I
        0                   %R8    12       1 us  (F12==1)  Tau_8: LED HOLD-off delay, i.e. delay between start of Tau_2 and the first flash
        0                   %R9    12       1 us  (F12==1)  Tau_9: LED Delay between flashes (applies only if R25>1?)
        1000                %R10   12       1 us  (F12==1)  Tau10: LED Width of each flash [see also: R8,R9,R25,F12,F13]
        multi.R11           %R11   12    gatelines          Address of 1st selected Gate Line (DO NOT MULTIPLY FOR PSI-2 & PSI-3!)
        geo.G3GL            %R12   12    glgroups           # of Gate Line Groups-1 to be read out
        multi.R13           %R13    8    gatelines          Gate Line Increment:  increment between reads (happens in gl-advance phase, during Tau_3, just before START_ROW)
        multi.R14           %R14    8    gatelines          Gate Line Group Size: simultaniously addressed gate lines (clocked into supertex shift register right after START_FRAME)
        0                   %R15   12    datalines          Address of 1st Data Line - must start at mux boundary, 16 in case of BB-ADC?
        geo.G3DL            %R16   12    datalines          # of Data Lines / 2 -1, multiple of preamp mux (512)
        0                   %R17         N/I
        0                   %R18         N/I
        0                   %R19    8    glgroups  (F8=0)   # of gate line groups between Tau_3 delays
        0                   %R20         N/I 
        300                 %R21   12     (50)ns            Tau21: before-sample integration time (SBEF): R21*50ns; starts 2.15us after START_ROW [ ??0.05*R21-5 in us]
        multi.R22           %R22   12    set by dips        Masda-R Preamplifier Gain Setting 2=PG5(0.725pF) 4=PG4(1.45pF) 8=PG3(2.9pF)
        0                   %R23         N/I
        0                   %R24         N/I
        multi.R25           %R25   12    flashes (F12==1)   # of LED flashes per acquisition cycle (0: really no LED flash)
        multi.R26           %R26   16    cycles             # of Ignore Cycles
        multi.R27           %R27   16    cycles             # of  Data  Cycles (continous if R26==0&&R27==0)
        200 %250 %20        %R28   12    cycles  (F12==1)   Initial Cycle to start LED flashes, zero-indexed (0: start at first cycle)
        100 %500            %R29   12    cycles  (F12==1)   # of Data Cycles with LED flashes (R29==0&R28==0: always flashing! R29==0&&R28>0: really no cycle with LED flashes, but still Tau_8,Tau_9&Tau10 Timing during Tau_2?)
        15                  %R30                            FIX # ADC bits -1, fixed to 15. internally a 4-bit register
        0                   %R31         N/I
        0                   %R32         N/I
        sum([
        0       %FO         N/I
        0       %F1         N/I? Cycle Mode: Single Cycle(0) or Continous Cycle(1)
        0       %F2         N/I? Frame Transfer Mode: Continuous vs. Single
        0       %F3         FIX set by acquisition software: Acquisition Request
        0       %F4         FIX set by acquisition software: Data Frame Transfer Request
        0       %F5         UNCOMMON Frame Summing Request
        0       %F6         N/I
        0       %F7         N/I
        0       %F8    readout ctrl for multiple GL groups between Tau_3 delays, see R19
        env.UseExtClock %F9 Tau_1 clock source         (0: internal, 1: External)
        0       %F10   Tau_2 & Tau_8 clock source (0: internal, 1: External)
        0       %F11   Tau_3 clock source         (0: internal, 1: External)
        1       %F12   Master LED Flashing control (see R8,R9,R10,R25,R28,R29,F13)
        0       %F13   Flash LED during ignore cycles (needs F12 as well to be active!)
        0       %F14        N/I
        0       %F15        UNCOMMON Offset Substraction Control
        ]'.*(2.^(0:15)))
      ];

meas.userdata=g3_acquisition_userdata( setup, env );
[compsys.s1 compsys.filedescriptors]=system('find /proc/ -maxdepth 3 -a \( -name cwd -o -name exe -o -regex ''.*/fd/.*'' \) -printf ''%p %l\n''');
[compsys.s2 compsys.psxafuw]=system('ps xafuw');
if ~flag.dryrun;
save(meas.MatFile);
g3_startacq_udata('localhost',9008,...
    meas.R,meas.userdata,meas.AcqFile,geo.G3_SORTMODE,flag.G3_nuke,mid==multi.nrofacq);
end
flag.G3_nuke=false;


% Jabber notification
%tool_notification(flag.first_run,'pion.ubuntu',meas,multi,2);
flag.first_run=false;

end


display('Measurement complete');

% Jabber notification that script is done
%multi.mid=0;  % flag to signal end of for-loop
%tool_notification(1,'pion.ubuntu',meas,multi,0);
